Node.js 异步I/O 理解
==


传统多线程异步
--
传统的异步是多线程的，当要同时做两件事的时候，他们是执行在不同的线程里的。  这就像是柜台卖东西，来了一个人就得找一个员工陪他，直到这个人走了这个员工才能接待下一个客人。店内的员工就像线程池里的空闲线程，空闲的时候可以去接待客人，可是同时只能接待一个人，要接待其他人就得找另外一个人。

电脑里的线程相当于一个员工团队，哪里需要去哪里。多线程的异步好处在于可以更多的占用系统的资源，每次开辟线程，就像是从这个团队里找一个人来，团队人总共就那么多，抢一个过来就多一点劳动力，接待的客人也就更多。而这样做的缺点在于创建和销毁线程的开销是非常大的，每个线程都需要占用资源，这样资源分配不过来，柜台没办法接待太多客人。并且如果有一个客人看的时间太久了就会让一名接待人员一直不能去接待其他客人，这样本来就吃紧的资源就更分配不过来了。

 

node.JS的单线程异步
--

如果拘泥于传统的异步，肯定会发出疑问：单线程怎么能异步？

让我们来想一个问题，什么是异步？最直白的回答就是"让两个操作同时进行"。可是在单线程里，一次只能做一件事情，怎们能有异步呢。如果是普通的操作自然是不能，可是io可以，因为io操作的等待时间内是不占用任何系统资源的，也就是说你尽可以放它慢慢弄，只要执行完了通知我一声就行了。

什么意思呢，我们拿烧水做饭的例子来讲。

在同步的模式下，我们先烧水，我们就等水烧开，烧开后再来切菜、煮饭，然后等饭煮熟后再来炒菜。

在多线程异步下，我们先烧水，这个同时我们要切菜和煮饭，那叫另一个人来切菜，切完菜后他发现要煮饭，可是自己接下来要炒菜，那看看刚刚烧水的人烧完了没有，烧完了就让他来煮饭，没烧完再叫另一个人来煮饭，自己继续炒菜。最后大家都做完了，这个事情就算玩了。

而单线程异步下，我们先烧水，然后放着水在那里烧，再去切菜。这时候菜切完了，先去检查水烧好了没，如果烧好了就用这个水去做点事，如果没烧好，继续放着烧，然后煮饭也和烧水一样，我不是放人去盯着有没有煮好，而是做完一件事情去看这件事有没有做好。

在node中，对于io的操作使用通知的方式，而不像传统的异步操作，使用线程去监视他。

我对node的事件轮询的理解是这样的，主线程分配任务下去，注册回调函数。主线程里在执行代码的时候io继续等待，主线程执行完毕后进行轮询，因为这个时候主线程是空闲状态，所以可以一直轮询，直到发现有某一个io操作给他发了信号告诉他我现在弄好了，你可以用这个数据，主线程的资源就拿来执行回调函数。也就是说从始至终都只有主线程在做事情，主线程要不然是在执行函数，要不然就是在进行事件的轮询，去寻找有哪个事件完成了需要执行他的回调函数。

换句话说，我们继续用刚刚的例子，这个人不是在切菜或者炒菜，就是在检查水有没有烧开，饭有没有煮熟。所以即使是单线程依旧能使用异步模式。
      
 
![](https://github.com/haoyuheng/Nodejs_Note/raw/master/Asynchronous_IO/node_io.png)
 

总结
--

多线程并不是异步的必须因素，这里谈一下io，io操作本身并不执行在程序中，而是交给别人去做，等他做好了我们再拿到结果。我之前考虑最多的就是io难道不阻塞吗，后来才明白io的时候线程是0消耗的，完全处于等待状态。

所谓的单线程异步，正是合理分配了io的等待时间，让主线程去做其他事情，在主线程空闲的时候才来检查等待的任务有没有完成。总的来说，node适合io多，高并发的事，因为这些事情不必等待，也不必创建新的线程，而是分给别人去做，node只需要等待结果就好了。但它并不适合计算密集型的事情，因为当一个计算阻塞了主线程，就无法使下一个任务被轮询到，后面所有的任务都会被阻塞住。

参考
--
[【1】浅析 Node.js 单线程模型](https://blog.csdn.net/z69183787/article/details/80591363)<br>
[【2】nodejs笔记之：事件驱动，线程池，非阻塞，异常处理等](https://blog.csdn.net/tyro_java/article/details/51290419)<br>
[【3】谈一谈Node中的异步和单线程](http://www.cnblogs.com/kazetotori/p/6036621.html)
